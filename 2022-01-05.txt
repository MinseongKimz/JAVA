*작성한날 : 2022.01.05
*작 성 자 : 김민성
*파일이름 : 2022-01-05.txt
*작성목적 : 수업내용 정리

프로토콜은 컴퓨터 내부에서, 또는 컴퓨터 사이에서 데이터의 교환 방식을 정의하는 규칙 체계

어제 내용 추가
실수 + 정수 연산 > 실수 연산

복합 대입 연산자 
=  : 대입 연산자. 우측부터 마치고 왼쪽으로 대입. 연산자 우선순위 ↓

+= : a += b	a를 b만큼 증가시켜라 >>  a = a+b  
-= : a -= b 	a를 b만큼 감소시켜라
*= : a *= b 	a를 b만큼 곱해라 
/= : a /= b 	a를 b만큼 나눠라
특징 : 피연산자  a(좌측) 의 값이 바뀜. 

관계연산자
좌측이 우측보다 크다.작다.... > < 
■관계연산자 결과는 true / false■

>=, <= (복합대입연산자와 관련 x)
== : 같다.	(java에서 = 는 대입으로 사용. equal의 의미를 쓰기위해 ==)
!= : 다르다.

논리연산자
&& : 논리 AND  : a && b  => a 와 b 모두 true 면 true
|| : 논리 OR   : a || b  => a 와 b 둘중 하나  true 면 true 
!  : 논리 NOT  : a ! b   => a 가 true면 false false 면 true 

단항연산자
부호 : + -, +는 생략 해도 되니 의미 없. - 는 부호를 바꿈.
증감 연산자
++ : 1만큼 증가 
-- : 1만큼 감소 

a++, ++a 차이는? 반영시점차이.
뒤에나오는 증감자 (postfix)
앞에나오는 증감자 (prefix)
 
++a : 지금 당장 1만큼 증가시켜라.
a++ : 다음처리에서 1만큼 증가시켜라. 조금더 까다롭다...


비트와 관련이 있는 연산자들.(비트 단위 연산자, 비트연산자)
비트 단위 연산자들은 연산이 빠르다.
& : 비트AND  1010 & 1011 = 1010 > 10 & 11 = 10
 
| : 비트 OR  1010 | 1011 = 1011 > 10 | 11 = 11

^ : 비트 XOR  배타적 논리합; 같으면 0 다르면 1

~ : 비트 not  비트단위 반전 !과 다름. ! 는 논리 반전

비트 쉬프트(shift) 연산자 -> 가장 빠른 연산.

<<  : (10)00001010<<2      비트를 2칸 왼쪽으로 이동~ ->  00101000 = 40
	왼쪽 비트 이동은 2의 n승 만큼 곱함 위에선 2^2 4배

>>> : (10)00001010>>>2     비트를 2칸 오른쪽으로 이동 -> 00000010 = 2 
	오른쪽 비트 이동은 2의 n승 만큼 나눔 

>>  : 비트를 만큼 이동 ,그러나 MSB최상단 비트에 따라 0이면 0을 채우고 1이면 1을 채움
ex)  10110100>>2  => 11101101
     01010101>>3  => 00001010   


	00000000 00000000 00000000 10000000 > a(128) int 형

	이걸 << 24 하면 어떻게 될까? 
        10000000 00000000 00000000 00000000  >> int 형 최소값 -21억 ~

        그럼 << 25 하면 어떻게 될까? 
        00000000 00000000 00000000 00000000  >> 0이됨

	그럼 << 32 하면 어떻게 될까? 
	00000000 00000000 00000000 10000000 >> 128 원래대로 돌아옴.
        이는 자바의 비트 설계때 이렇게 만들었다 함.
	원래 자기자리 찾기 전까진 보이지 않다가 자기 값이 되면 보임.
        

"문자열" 은 일반적인 자료형 x ? 메모리 data 얼마나 잡을지 가늠이 안됨.
          -> 객체화

객체 지향 프로그래밍 기법
객체 지향 프로그램
객체 지향 언어

String 이라는 자료형 사용. S 가 대문자..! -> 클래스의 일종..?


printf(), format()  : 포멧에 맞게 출력이 가능
printf("%d",1);
 